using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Fallout4;
using Noggog;
using Mutagen.Bethesda.Plugins;


namespace FOLIP
{
    public class Program
    {
        static Lazy<LodSettings> _lazySettings = null!;
        static LodSettings Settings => _lazySettings.Value;
        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<IFallout4Mod, IFallout4ModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out _lazySettings)
                .SetTypicalOpen(GameRelease.Fallout4, "FOLIP-Dynamic.esp")
                .Run(args);
        }
        public static void RunPatch(IPatcherState<IFallout4Mod, IFallout4ModGetter> state)
        {
            Console.WriteLine("FOLIP START");

            // Gather Assets.
            Console.WriteLine("Identifying LOD assets...");

            List<string> lodMaterialFiles = new();
            List<string> lod4Meshes = new();
            List<string> lod8Meshes = new();
            List<string> lod16Meshes = new();
            List<string> lod32Meshes = new();
            List<string> lodMeshes = new();

            string[] lodMaterialFileLocations = { $"{state.DataFolderPath}\\materials\\lod", $"{state.DataFolderPath}\\materials\\dlc03\\lod", $"{state.DataFolderPath}\\materials\\dlc04\\lod" };
            string[] lodMeshesFileLocations = { $"{state.DataFolderPath}\\meshes\\lod", $"{state.DataFolderPath}\\meshes\\dlc03\\lod", $"{state.DataFolderPath}\\meshes\\dlc04\\lod" };
            string[] patternReplaceListMaterials = { "", "dlc03\\", "dlc04\\" };
            string[] patternReplaceListMeshes = { "lod\\", "dlc03\\lod\\", "dlc04\\lod\\" };

            lodMaterialFiles = GameAssets.Files(lodMaterialFileLocations, "*.bgsm", patternReplaceListMaterials);

            if (Settings.devCode)
            {
                lod4Meshes = GameAssets.Files(lodMeshesFileLocations, "*lod_0.nif", patternReplaceListMeshes);
                lod8Meshes = GameAssets.Files(lodMeshesFileLocations, "*lod_1.nif", patternReplaceListMeshes);
                lod16Meshes = GameAssets.Files(lodMeshesFileLocations, "*lod_2.nif", patternReplaceListMeshes);
                lod32Meshes = GameAssets.Files(lodMeshesFileLocations, "*lod_3.nif", patternReplaceListMeshes);
                lodMeshes = GameAssets.Files(lodMeshesFileLocations, "*lod.nif", patternReplaceListMeshes);
            }

            // Handle Material Swaps.
            Console.WriteLine("Adding LOD material swaps...");

            List<string> missingMaterials = new();

            foreach (var materialSwap in state.LoadOrder.PriorityOrder.MaterialSwap().WinningOverrides())
            {
                List<string> lodSubstitutionsOriginal = new();
                List<string> lodSubstitutionsReplacement = new();
                List<string> existingSubstitutions = new();
                int n = -1;

                //make a list of existing substitutions, which we will need to then check to make sure we don't add duplicate substitutions
                foreach (var substitution in materialSwap.Substitutions)
                {
                    var existingOriginalSubstitution = substitution.OriginalMaterial;
                    if (existingOriginalSubstitution is null) continue;
                    existingOriginalSubstitution = existingOriginalSubstitution.ToLower();
                    existingSubstitutions.Add(existingOriginalSubstitution);
                }

                foreach (var substitution in materialSwap.Substitutions)
                {
                    var theOriginalMaterial = substitution.OriginalMaterial;
                    if (theOriginalMaterial is null) continue;
                    theOriginalMaterial = theOriginalMaterial.ToLower();

                    // Skip if the original material does not have a direct lod material.
                    if (!lodMaterialFiles.Contains(theOriginalMaterial)) continue;

                    var theReplacementMaterial = substitution.ReplacementMaterial;
                    if (theReplacementMaterial is null) continue;
                    theReplacementMaterial = theReplacementMaterial.ToLower();

                    // I used this code to find a specific problematic material swap, where the swap file didn't exist.
                    //if (theReplacementMaterial == "landscape\\ground\\grassdried01.bgsm")
                    //    Console.WriteLine(materialSwap.FormKey);

                    // Material replacements with a ColorRemappingIndex should be appended onto the lod material name.
                    if (substitution.ColorRemappingIndex is not null)
                    {
                        theReplacementMaterial = theReplacementMaterial.Replace(".bgsm", $"_{substitution.ColorRemappingIndex}.bgsm");
                        if (Settings.verboseConsoleLog) Console.WriteLine($"Note for LOD author: {materialSwap.FormKey} Material Swap has a Color Remapping Index of {substitution.ColorRemappingIndex}.");
                    }

                    // Skip if the replacement material does not have a direct lod material.
                    if (!lodMaterialFiles.Contains(theReplacementMaterial))
                    {
                        if (substitution.ColorRemappingIndex is not null)
                            if (Settings.verboseConsoleLog) Console.WriteLine($"Missing {theReplacementMaterial}");
                        if (!missingMaterials.Contains(theReplacementMaterial))
                            missingMaterials.Add($"{theReplacementMaterial} RM\n\tfrom {theOriginalMaterial} OM.");
                        continue;
                    }

                    // Turns theOriginalMaterial into the path of the matching lod material. 
                    theOriginalMaterial = theOriginalMaterial.Split(Path.DirectorySeparatorChar)[0] switch
                    {
                        "dlc04" => theOriginalMaterial.Replace("dlc04\\", "DLC04\\LOD\\"),
                        "dlc03" => theOriginalMaterial.Replace("dlc03\\", "DLC03\\LOD\\"),
                        _ => $"LOD\\{theOriginalMaterial}",
                    };

                    // Skip if an already existing material swap exists for the lod material.
                    if (existingSubstitutions.Contains(theOriginalMaterial.ToLower())) continue;

                    // Turns theReplacementMaterial into the path of the matching lod material.
                    theReplacementMaterial = theReplacementMaterial.Split(Path.DirectorySeparatorChar)[0] switch
                    {
                        "dlc04" => theReplacementMaterial.Replace("dlc04\\", "DLC04\\LOD\\"),
                        "dlc03" => theReplacementMaterial.Replace("dlc03\\", "DLC03\\LOD\\"),
                        _ => $"LOD\\{theReplacementMaterial}",
                    };

                    //If the material swap defines replacing with the exact same material, then skip. Yes, Bethesda has put some swaps that literally say to swap with the exact same material for no reason.
                    if (theOriginalMaterial == theReplacementMaterial) continue;

                    //If the original material and replacement material both have direct lod materials, add them to the lists.
                    lodSubstitutionsOriginal.Add(theOriginalMaterial);
                    lodSubstitutionsReplacement.Add(theReplacementMaterial);
                    n += 1;
                }

                // Skip if no lod material swaps were added.
                if (n < 0) continue;

                // Add material swap to patch
                var myFavoriteMaterialSwap = state.PatchMod.MaterialSwaps.GetOrAddAsOverride(materialSwap);

                // Add missing lod material swaps.
                while (n >= 0)
                {
                    myFavoriteMaterialSwap.Substitutions.Add(new MaterialSubstitution
                    {
                        OriginalMaterial = $"{lodSubstitutionsOriginal[n]}",
                        ReplacementMaterial = $"{lodSubstitutionsReplacement[n]}"
                    });
                    n--;
                }
            }

            
            //Add notes about possible missed materials for material swaps for lod author.
            if (Settings.verboseConsoleLog)
            {
                missingMaterials = missingMaterials.OrderBy(q => q).ToList();
                foreach (string missingMaterial in missingMaterials) Console.WriteLine($"Note for LOD author: Skipped\t{missingMaterial}");
            }

            if (Settings.devCode)
            {
                // Add lod meshes to static records
                Console.WriteLine("Assigning LOD models...");

                foreach (var staticRecord in state.LoadOrder.PriorityOrder.Static().WinningOverrides())
                {
                    // Skip null statics.
                    if (staticRecord is null || staticRecord.Model is null || staticRecord.Model.File is null) continue;
                    
                    // Split model file name path to see if it is from a dlc.
                    string baseFolder = staticRecord.Model.File.Split(Path.DirectorySeparatorChar)[0].ToLower();

                    string possibleLOD4Mesh;
                    string possibleLOD8Mesh;
                    string possibleLOD16Mesh;
                    string possibleLOD32Mesh;
                    string possibleLODMesh;
                    string[] assignedlodMeshes = { "", "", "", "" };
                    bool hasLodMeshes = false;

                    string colorRemap = "";
                    if (staticRecord.Model.ColorRemappingIndex is not null)
                    {
                        colorRemap = $"_{staticRecord.Model.ColorRemappingIndex}";
                        if (Settings.verboseConsoleLog) Console.WriteLine($"Note for LOD author: {staticRecord.FormKey} Static has a Color Remapping Index of {staticRecord.Model.ColorRemappingIndex}.");
                    }

                    // Get file names of possible lod meshes based off the filename (e.g. meshes\somefolder\somemodel.nif would match to meshes\lod\somefolder\somemodel_lod_0.nif).
                    switch (baseFolder)
                    {
                        case "dlc03":
                            possibleLOD4Mesh = $"{staticRecord.Model.File.ToLower().Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_0.nif")}";
                            possibleLOD8Mesh = $"{staticRecord.Model.File.ToLower().Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_1.nif")}";
                            possibleLOD16Mesh = $"{staticRecord.Model.File.ToLower().Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_2.nif")}";
                            possibleLOD32Mesh = $"{staticRecord.Model.File.ToLower().Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_3.nif")}";
                            possibleLODMesh = $"{staticRecord.Model.File.ToLower().Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod.nif")}";
                            break;
                        case "dlc04":
                            possibleLOD4Mesh = $"{staticRecord.Model.File.ToLower().Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_0.nif")}";
                            possibleLOD8Mesh = $"{staticRecord.Model.File.ToLower().Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_1.nif")}";
                            possibleLOD16Mesh = $"{staticRecord.Model.File.ToLower().Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_2.nif")}";
                            possibleLOD32Mesh = $"{staticRecord.Model.File.ToLower().Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_3.nif")}";
                            possibleLODMesh = $"{staticRecord.Model.File.ToLower().Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod.nif")}";
                            break;
                        default:
                            possibleLOD4Mesh = $"lod\\{staticRecord.Model.File.ToLower().Replace(".nif", $"{colorRemap}_lod_0.nif")}";
                            possibleLOD8Mesh = $"lod\\{staticRecord.Model.File.ToLower().Replace(".nif", $"{colorRemap}_lod_1.nif")}";
                            possibleLOD16Mesh = $"lod\\{staticRecord.Model.File.ToLower().Replace(".nif", $"{colorRemap}_lod_2.nif")}";
                            possibleLOD32Mesh = $"lod\\{staticRecord.Model.File.ToLower().Replace(".nif", $"{colorRemap}_lod_3.nif")}";
                            possibleLODMesh = $"lod\\{staticRecord.Model.File.ToLower().Replace(".nif", $"{colorRemap}_lod.nif")}";
                            break;
                    }

                    // Check if the possible lod meshes do actually exist. If they do, add them to the list of lod meshes to possibly assign.
                    if (lod4Meshes.Contains(possibleLOD4Mesh))
                    {
                        hasLodMeshes = true;
                        assignedlodMeshes[0] = possibleLOD4Mesh;
                    }
                    else if (lodMeshes.Contains(possibleLODMesh))
                    {
                        hasLodMeshes = true;
                        assignedlodMeshes[0] = possibleLODMesh;
                    }
                    if (lod8Meshes.Contains(possibleLOD8Mesh))
                    {
                        hasLodMeshes = true;
                        assignedlodMeshes[1] = possibleLOD8Mesh;
                    }
                    if (lod16Meshes.Contains(possibleLOD16Mesh))
                    {
                        hasLodMeshes = true;
                        assignedlodMeshes[2] = possibleLOD16Mesh;
                    }
                    if (lod32Meshes.Contains(possibleLOD32Mesh))
                    {
                        hasLodMeshes = true;
                        assignedlodMeshes[3] = possibleLOD32Mesh;
                    }

                    // Skip statics that don't have any lod meshes
                    if (!hasLodMeshes) continue;

                    // Retrieve any DistantLods meshes currently assigned.
                    List<string> currentLodMeshes = new();
                    foreach (var distantLodList in staticRecord.DistantLods)
                    {
                        if (distantLodList.Mesh.Length > 0)
                            currentLodMeshes.Add(distantLodList.Mesh.ToLower());
                    }

                    while (currentLodMeshes.Count < 4)
                        currentLodMeshes.Add("");

                    // Checks to see if DistantLods meshes detected are assigned.
                    bool hasDistantLodMeshesChanged = true;
                    for (int i = 0; i < 4; i++)
                    {
                        // Is there a assigned lod mesh found?
                        bool FoundLodMesh = false;
                        if (assignedlodMeshes[i].Length > 0)
                            FoundLodMesh = true;

                        // Is there an already existing assigned lod mesh?
                        bool ExistingLodMesh = false;
                        if (currentLodMeshes is not null && currentLodMeshes.Count > i)
                            ExistingLodMesh = true;

                        // If there is no found lod mesh, but one is already assigned, use it.
                        if (!FoundLodMesh && ExistingLodMesh && currentLodMeshes is not null)
                            assignedlodMeshes[i] = currentLodMeshes[i];
                    }

                    if (currentLodMeshes is not null && assignedlodMeshes.SequenceEqual(currentLodMeshes))
                        hasDistantLodMeshesChanged = false;

                    // Skip if the static already has the HasDistantLOD flag and its lod meshes hasn't changed.
                    if (EnumExt.HasFlag(staticRecord.MajorRecordFlagsRaw, (int)Static.MajorFlag.HasDistantLod) && !hasDistantLodMeshesChanged) continue;

                    // Add the static to the patch
                    var myFavoriteStatic = state.PatchMod.Statics.GetOrAddAsOverride(staticRecord);

                    // Set the HasDistantLOD flag.
                    myFavoriteStatic.MajorRecordFlagsRaw = EnumExt.SetFlag(myFavoriteStatic.MajorRecordFlagsRaw, (int)Static.MajorFlag.HasDistantLod, true);

                    // Optional readout of static with its lod meshes assigned.
                    if (Settings.verboseConsoleLog)
                        Console.WriteLine($"{myFavoriteStatic.FormKey}     {assignedlodMeshes[0]}     {assignedlodMeshes[1]}     {assignedlodMeshes[2]}     {assignedlodMeshes[3]}");
                    
                    // Clear assigned DistantLods meshes.
                    myFavoriteStatic.DistantLods.Clear();

                    // Assign DistantLods meshes.
                    for (int i = 0; i < 4; i++)
                    {
                        if (assignedlodMeshes[i].Length > 0)
                        {
                            var item = new DistantLod()
                            {
                                Mesh = assignedlodMeshes[i],
                                Data = new byte[260 - assignedlodMeshes[i].Length - 1],
                            };
                            myFavoriteStatic.DistantLods.Add(item);
                        }
                    }
                }


                //Add lod meshes for moveable statics... this might be hard lol
                Console.WriteLine("Adding LOD for Moveable Statics...");

                IDictionary<Mutagen.Bethesda.Plugins.FormKey, Mutagen.Bethesda.Plugins.FormKey> movableStaticLod = new Dictionary<Mutagen.Bethesda.Plugins.FormKey, Mutagen.Bethesda.Plugins.FormKey>();
                IDictionary<Mutagen.Bethesda.Plugins.FormKey, Mutagen.Bethesda.Plugins.FormKey> movableStaticLodMaterialSwaps = new Dictionary<Mutagen.Bethesda.Plugins.FormKey, Mutagen.Bethesda.Plugins.FormKey>();

                foreach (var moveableStaticRecord in state.LoadOrder.PriorityOrder.MovableStatic().WinningOverrides())
                {
                    // Skip null statics.
                    if (moveableStaticRecord is null || moveableStaticRecord.Model is null || moveableStaticRecord.Model.File is null) continue;

                    // Split model file name path to see if it is from a dlc.
                    string baseFolder = moveableStaticRecord.Model.File.Split(Path.DirectorySeparatorChar)[0].ToLower();

                    string possibleLOD4Mesh;
                    string possibleLOD8Mesh;
                    string possibleLOD16Mesh;
                    string possibleLOD32Mesh;
                    string[] assignedlodMeshes = { "", "", "", "" };
                    bool hasLodMeshes = false;

                    string colorRemap = "";
                    if (moveableStaticRecord.Model.ColorRemappingIndex is not null)
                    {
                        colorRemap = $"_{moveableStaticRecord.Model.ColorRemappingIndex}";
                        if (Settings.verboseConsoleLog) Console.WriteLine($"Note for LOD author: {moveableStaticRecord.FormKey} Moveable Static has a Color Remapping Index of {moveableStaticRecord.Model.ColorRemappingIndex}.");
                    }

                    // Get file names of possible lod meshes based off the filename (e.g. meshes\somefolder\somemodel.nif would match to meshes\lod\somefolder\somemodel_lod_0.nif).
                    switch (baseFolder)
                    {
                        case "dlc03":
                            possibleLOD4Mesh = $"{moveableStaticRecord.Model.File.ToLower().Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_0.nif")}";
                            possibleLOD8Mesh = $"{moveableStaticRecord.Model.File.ToLower().Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_1.nif")}";
                            possibleLOD16Mesh = $"{moveableStaticRecord.Model.File.ToLower().Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_2.nif")}";
                            possibleLOD32Mesh = $"{moveableStaticRecord.Model.File.ToLower().Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_3.nif")}";
                            break;
                        case "dlc04":
                            possibleLOD4Mesh = $"{moveableStaticRecord.Model.File.ToLower().Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_0.nif")}";
                            possibleLOD8Mesh = $"{moveableStaticRecord.Model.File.ToLower().Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_1.nif")}";
                            possibleLOD16Mesh = $"{moveableStaticRecord.Model.File.ToLower().Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_2.nif")}";
                            possibleLOD32Mesh = $"{moveableStaticRecord.Model.File.ToLower().Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_3.nif")}";
                            break;
                        default:
                            possibleLOD4Mesh = $"lod\\{moveableStaticRecord.Model.File.ToLower().Replace(".nif", $"{colorRemap}_lod_0.nif")}";
                            possibleLOD8Mesh = $"lod\\{moveableStaticRecord.Model.File.ToLower().Replace(".nif", $"{colorRemap}_lod_1.nif")}";
                            possibleLOD16Mesh = $"lod\\{moveableStaticRecord.Model.File.ToLower().Replace(".nif", $"{colorRemap}_lod_2.nif")}";
                            possibleLOD32Mesh = $"lod\\{moveableStaticRecord.Model.File.ToLower().Replace(".nif", $"{colorRemap}_lod_3.nif")}";
                            break;
                    }

                    // Check if the possible lod meshes do actually exist. If they do, add them to the list of lod meshes to possibly assign.
                    if (lod4Meshes.Contains(possibleLOD4Mesh))
                    {
                        hasLodMeshes = true;
                        assignedlodMeshes[0] = possibleLOD4Mesh;
                    }
                    if (lod8Meshes.Contains(possibleLOD8Mesh))
                    {
                        hasLodMeshes = true;
                        assignedlodMeshes[1] = possibleLOD8Mesh;
                    }
                    if (lod16Meshes.Contains(possibleLOD16Mesh))
                    {
                        hasLodMeshes = true;
                        assignedlodMeshes[2] = possibleLOD16Mesh;
                    }
                    if (lod32Meshes.Contains(possibleLOD32Mesh))
                    {
                        hasLodMeshes = true;
                        assignedlodMeshes[3] = possibleLOD32Mesh;
                    }

                    // Skip moveable statics that don't have any lod meshes
                    if (!hasLodMeshes) continue;

                    // Add a new fake static record for the moveable static
                    var fakeStatic = state.PatchMod.Statics.AddNew("FOLIP_" + moveableStaticRecord.EditorID + "_FakeStatic");
                    fakeStatic.MajorRecordFlagsRaw = (int)Static.MajorFlag.HasDistantLod;
                    fakeStatic.Model = new Model();
                    if (moveableStaticRecord.Model.MaterialSwap is not null)
                        fakeStatic.Model.MaterialSwap.SetTo(moveableStaticRecord.Model.MaterialSwap);
                    if (moveableStaticRecord.Model.ColorRemappingIndex is not null)
                        fakeStatic.Model.ColorRemappingIndex = moveableStaticRecord.Model.ColorRemappingIndex;
                    fakeStatic.ObjectBounds = new ObjectBounds();
                    if (moveableStaticRecord.ObjectBounds is not null)
                    {
                        fakeStatic.ObjectBounds.First = moveableStaticRecord.ObjectBounds.First;
                        fakeStatic.ObjectBounds.Second = moveableStaticRecord.ObjectBounds.Second;
                    }

                    // Add the lods to the fake static
                    for (int i = 0; i < 4; i++)
                    {
                        if (assignedlodMeshes[i].Length > 0)
                        {
                            var item = new DistantLod()
                            {
                                Mesh = assignedlodMeshes[i],
                                Data = new byte[260 - assignedlodMeshes[i].Length - 1],
                            };
                            fakeStatic.DistantLods.Add(item);
                        }
                    }
                    movableStaticLod.Add(moveableStaticRecord.FormKey, fakeStatic.FormKey);
                    if (moveableStaticRecord.Model.MaterialSwap is not null)
                        movableStaticLodMaterialSwaps.Add(moveableStaticRecord.FormKey, moveableStaticRecord.Model.MaterialSwap.FormKey);
                }

                // Iterate over placed objects.
                foreach (var placedObjectGetter in state.LoadOrder.PriorityOrder.OnlyEnabled().PlacedObject().WinningContextOverrides(state.LinkCache))
                {
                    if (!movableStaticLod.ContainsKey(placedObjectGetter.Record.Base.FormKey)) continue;
                    if (!placedObjectGetter.TryGetParentContext<IWorldspace, IWorldspaceGetter>(out var worldspaceContext)) continue;
                    IPlacedObject copiedPlacedObject = placedObjectGetter.DuplicateIntoAsNewRecord(state.PatchMod);
                    copiedPlacedObject.Base.SetTo(movableStaticLod[placedObjectGetter.Record.Base.FormKey]);
                }
            }

            // Fix bugs in mods

            IFallout4ModGetter? AnnexTheCommonwealth = state.LoadOrder.TryGetValue(ModKey.FromFileName("AnnexTheCommonwealth.esm"))?.Mod ?? null;
            if (AnnexTheCommonwealth is not null)
            {
                foreach (var staticRecord in AnnexTheCommonwealth.Statics)
                {
                    if (!EnumExt.HasFlag(staticRecord.MajorRecordFlagsRaw, (int)Static.MajorFlag.HasDistantLod)) continue;

                    //add it to the patch
                    var myFavoriteStatic = state.PatchMod.Statics.GetOrAddAsOverride(staticRecord);

                    //remove flag
                    myFavoriteStatic.MajorRecordFlagsRaw = EnumExt.SetFlag(staticRecord.MajorRecordFlagsRaw, (int)Static.MajorFlag.HasDistantLod, false);
                    Console.WriteLine($"Removed HasDistantLOD flag from {staticRecord.FormKey}.");
                }
            }
        }
    }
}
