using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Fallout4;
using Noggog;
using Mutagen.Bethesda.Plugins;
using System.Text.Json;

namespace FOLIP
{
    public class Program
    {
        static Lazy<LodSettings> _lazySettings = null!;
        static LodSettings Settings => _lazySettings.Value;
        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                //.AddRunnabilityCheck(CheckRunnability)
                .AddPatch<IFallout4Mod, IFallout4ModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out _lazySettings)
                .SetTypicalOpen(GameRelease.Fallout4, "FOLIP-Dynamic.esp")
                .Run(args);
        }

//        public static void CheckRunnability(IRunnabilityState state)
//        {
//            if (!File.Exists($"{state.DataFolderPath}\\FOLIP\\FOLIP - New LODs - MaterialSwapMap.json"))
//            {
//                Console.WriteLine(@"****************************************************************************************************************************************************************

//Please update the FOLIP mod (not this patcher) to the latest version! Missing required file FOLIP\FOLIP - New LODs - MaterialSwapMap.json.

//****************************************************************************************************************************************************************");
//                throw new TaskCanceledException("Please update the FOLIP mod (not this patcher) to the latest version! Missing required file FOLIP\\FOLIP - New LODs - MaterialSwapMap.json.");
//            }
//            if (!File.Exists($"{state.DataFolderPath}\\FOLIP\\FOLIP - New LODs - LODRules.json"))
//            {
//                Console.WriteLine(@"****************************************************************************************************************************************************************

//Please update the FOLIP mod (not this patcher) to the latest version! Missing required file FOLIP\FOLIP - New LODs - LODRules.json.

//****************************************************************************************************************************************************************");
//                throw new TaskCanceledException("Please update the FOLIP mod (not this patcher) to the latest version! Missing required file FOLIP\\FOLIP - New LODs - LODRules.json.");
//            }
//        }

        public static void RunPatch(IPatcherState<IFallout4Mod, IFallout4ModGetter> state)
        {
            Console.WriteLine("FOLIP START");

            Dictionary<string, List<string>> materialSwapMap = new();
            Dictionary<string, Dictionary<string, string>> LODRules = new();

            // Add Rules
            foreach (var mod in state.LoadOrder)
            {
                string pluginName = mod.Key.Name;
                if (File.Exists($"{state.DataFolderPath}\\FOLIP\\{pluginName} - MaterialSwapMap.json"))
                {
                    string jsonModString = File.ReadAllText($"{state.DataFolderPath}\\FOLIP\\{pluginName} - MaterialSwapMap.json");
                    var modMaterialSwapMap = JsonSerializer.Deserialize<Dictionary<string, List<string>>>(jsonModString);
                    if (modMaterialSwapMap is not null)
                        modMaterialSwapMap.ToList().ForEach(x => materialSwapMap[x.Key] = x.Value);
                    Console.WriteLine($"Using {pluginName} - MaterialSwapMap.json");
                }
                if (File.Exists($"{state.DataFolderPath}\\FOLIP\\{pluginName} - LODRules.json"))
                {
                    string LODRulesJson = File.ReadAllText($"{state.DataFolderPath}\\FOLIP\\{pluginName} - LODRules.json");
                    var modLODRules = JsonSerializer.Deserialize<Dictionary<string, Dictionary<string, string>>>(LODRulesJson);
                    if (modLODRules is not null)
                        modLODRules.ToList().ForEach(x => LODRules[x.Key] = x.Value);
                    Console.WriteLine($"Using {pluginName} - LODRules.json");
                }
            }

            if (File.Exists($"{state.DataFolderPath}\\FOLIP\\UserRules.json"))
            {
                string LODRulesJson = File.ReadAllText($"{state.DataFolderPath}\\FOLIP\\UserRules.json");
                var userLODRules = JsonSerializer.Deserialize<Dictionary<string, Dictionary<string, string>>>(LODRulesJson);
                if (userLODRules is not null)
                    userLODRules.ToList().ForEach(x => LODRules[x.Key] = x.Value);
                Console.WriteLine($"Using UserRules.json");
            }

            // Gather Assets.
            Console.WriteLine("Identifying LOD assets...");

            List<string> lodMaterialFiles = new();
            List<string> lod4Meshes = new();
            List<string> lod8Meshes = new();
            List<string> lod16Meshes = new();
            List<string> lod32Meshes = new();
            List<string> lodMeshes = new();

            string[] lodMaterialFileLocations = { $"{state.DataFolderPath}\\materials\\lod", $"{state.DataFolderPath}\\materials\\dlc03\\lod", $"{state.DataFolderPath}\\materials\\dlc04\\lod" };
            string[] lodMeshesFileLocations = { $"{state.DataFolderPath}\\meshes\\lod", $"{state.DataFolderPath}\\meshes\\dlc03\\lod", $"{state.DataFolderPath}\\meshes\\dlc04\\lod" };
            string[] patternReplaceListMaterials = { "", "dlc03\\", "dlc04\\" };
            string[] patternReplaceListMeshes = { "lod\\", "dlc03\\lod\\", "dlc04\\lod\\" };

            lodMaterialFiles = GameAssets.Files(lodMaterialFileLocations, "*.bgsm", patternReplaceListMaterials);

            lod4Meshes = GameAssets.Files(lodMeshesFileLocations, "*lod_0.nif", patternReplaceListMeshes);
            lod8Meshes = GameAssets.Files(lodMeshesFileLocations, "*lod_1.nif", patternReplaceListMeshes);
            lod16Meshes = GameAssets.Files(lodMeshesFileLocations, "*lod_2.nif", patternReplaceListMeshes);
            lod32Meshes = GameAssets.Files(lodMeshesFileLocations, "*lod_3.nif", patternReplaceListMeshes);
            lodMeshes = GameAssets.Files(lodMeshesFileLocations, "*lod.nif", patternReplaceListMeshes);

            // Handle Material Swaps.
            Console.WriteLine("Adding LOD material swaps...");

            List<string> missingMaterials = new();

            foreach (var materialSwap in state.LoadOrder.PriorityOrder.MaterialSwap().WinningOverrides())
            {
                List<string> lodSubstitutionsOriginal = new();
                List<string> lodSubstitutionsReplacement = new();
                List<string> existingSubstitutions = new();
                int n = -1;

                //make a list of existing substitutions, which we will need to then check to make sure we don't add duplicate substitutions
                foreach (var substitution in materialSwap.Substitutions)
                {
                    var existingOriginalSubstitution = substitution.OriginalMaterial;
                    if (existingOriginalSubstitution is null) continue;
                    existingOriginalSubstitution = existingOriginalSubstitution.ToLower();
                    existingSubstitutions.Add(existingOriginalSubstitution);
                }

                foreach (var substitution in materialSwap.Substitutions)
                {
                    var theOriginalMaterial = substitution.OriginalMaterial;
                    if (theOriginalMaterial is null) continue;
                    theOriginalMaterial = theOriginalMaterial.ToLower();

                    bool hasDirectLODOriginalMaterial = false;
                    if (lodMaterialFiles.Contains(theOriginalMaterial))
                        hasDirectLODOriginalMaterial = true;

                    bool hasRuleLODOriginalMaterial = false;
                    List<string> ruleLODOriginalMaterials = new();
                    if (materialSwapMap is not null && materialSwapMap.ContainsKey(theOriginalMaterial))
                    {
                        ruleLODOriginalMaterials = materialSwapMap[theOriginalMaterial];
                        hasRuleLODOriginalMaterial = true;
                    }

                    // Skip if no lod materials for the original material
                    if (!hasDirectLODOriginalMaterial && !hasRuleLODOriginalMaterial) continue;

                    var theReplacementMaterial = substitution.ReplacementMaterial;
                    if (theReplacementMaterial is null) continue;
                    theReplacementMaterial = theReplacementMaterial.ToLower();

                    // I used this code to find a specific problematic material swap, where the swap file didn't exist.
                    //if (theReplacementMaterial == "landscape\\ground\\grassdried01.bgsm")
                    //    Console.WriteLine(materialSwap.FormKey);

                    // Material replacements with a ColorRemappingIndex should be appended onto the lod material name.
                    if (substitution.ColorRemappingIndex is not null)
                    {
                        theReplacementMaterial = theReplacementMaterial.Replace(".bgsm", $"_{substitution.ColorRemappingIndex}.bgsm");
                        if (Settings.devSettings.verboseConsoleLog) Console.WriteLine($"Note for LOD author: {materialSwap.FormKey} Material Swap has a Color Remapping Index of {substitution.ColorRemappingIndex}.");
                    }

                    bool hasDirectLODReplacementMaterial = false;
                    if (lodMaterialFiles.Contains(theReplacementMaterial))
                        hasDirectLODReplacementMaterial = true;

                    bool hasRuleLODReplacementMaterial = false;
                    string ruleLODReplacementMaterial = "";
                    if (materialSwapMap is not null && materialSwapMap.ContainsKey(theReplacementMaterial))
                    {
                        ruleLODReplacementMaterial = materialSwapMap[theReplacementMaterial][0];
                        hasRuleLODReplacementMaterial = true;
                    }

                    if (!hasDirectLODReplacementMaterial && !hasRuleLODReplacementMaterial)
                    {
                        if (substitution.ColorRemappingIndex is not null)
                            if (Settings.devSettings.verboseConsoleLog) Console.WriteLine($"Missing {theReplacementMaterial}");
                        if (!missingMaterials.Contains(theReplacementMaterial))
                            missingMaterials.Add($"{theReplacementMaterial} RM\n\tfrom {theOriginalMaterial} OM.");
                        continue;
                    }

                    // Turns theOriginalMaterial into the path of the matching lod material. 
                    theOriginalMaterial = theOriginalMaterial.Split(Path.DirectorySeparatorChar)[0] switch
                    {
                        "dlc04" => theOriginalMaterial.Replace("dlc04\\", "dlc04\\lod\\"),
                        "dlc03" => theOriginalMaterial.Replace("dlc03\\", "dlc03\\lod\\"),
                        _ => $"lod\\{theOriginalMaterial}",
                    };

                    bool hasExistingDirectLODSubstitution = false;
                    if (existingSubstitutions.Contains(theOriginalMaterial.ToLower()))
                        hasExistingDirectLODSubstitution = true;

                    // Turns theReplacementMaterial into the path of the matching lod material.
                    theReplacementMaterial = theReplacementMaterial.Split(Path.DirectorySeparatorChar)[0] switch
                    {
                        "dlc04" => theReplacementMaterial.Replace("dlc04\\", "dlc04\\lod\\"),
                        "dlc03" => theReplacementMaterial.Replace("dlc03\\", "dlc03\\lod\\"),
                        _ => $"lod\\{theReplacementMaterial}",
                    };

                    bool originalIsReplacement = false;
                    if (theOriginalMaterial == theReplacementMaterial)
                        originalIsReplacement = true;

                    //Adding necessary material swaps to the list
                    if (!hasExistingDirectLODSubstitution && !originalIsReplacement && hasDirectLODReplacementMaterial && hasDirectLODOriginalMaterial && !lodSubstitutionsOriginal.Contains(theOriginalMaterial))
                    {
                        lodSubstitutionsOriginal.Add(theOriginalMaterial);
                        lodSubstitutionsReplacement.Add(theReplacementMaterial);
                        n += 1;
                    }
                    if (materialSwapMap is not null && hasRuleLODOriginalMaterial)
                    {
                        if (hasRuleLODReplacementMaterial)
                        {
                            foreach (var eachLODOriginalMaterial in ruleLODOriginalMaterials)
                            {
                                if (existingSubstitutions.Contains(eachLODOriginalMaterial) || lodSubstitutionsOriginal.Contains(eachLODOriginalMaterial)) continue;
                                lodSubstitutionsOriginal.Add(eachLODOriginalMaterial);
                                lodSubstitutionsReplacement.Add(ruleLODReplacementMaterial);
                                n += 1;
                            }
                        }
                        else if (hasDirectLODReplacementMaterial)
                        {
                            foreach (var eachLODOriginalMaterial in ruleLODOriginalMaterials)
                            {
                                if (existingSubstitutions.Contains(eachLODOriginalMaterial) || lodSubstitutionsOriginal.Contains(eachLODOriginalMaterial)) continue;
                                lodSubstitutionsOriginal.Add(eachLODOriginalMaterial);
                                lodSubstitutionsReplacement.Add(theReplacementMaterial);
                                n += 1;
                            }
                        }
                    }
                }

                // Skip if no lod material swaps were added.
                if (n < 0) continue;

                // Add material swap to patch
                var myFavoriteMaterialSwap = state.PatchMod.MaterialSwaps.GetOrAddAsOverride(materialSwap);

                // Add missing lod material swaps.
                while (n >= 0)
                {
                    myFavoriteMaterialSwap.Substitutions.Add(new MaterialSubstitution
                    {
                        OriginalMaterial = $"{lodSubstitutionsOriginal[n]}",
                        ReplacementMaterial = $"{lodSubstitutionsReplacement[n]}"
                    });
                    n--;
                }
            }

            
            //Add notes about possible missed materials for material swaps for lod author.
            if (Settings.devSettings.verboseConsoleLog)
            {
                missingMaterials = missingMaterials.OrderBy(q => q).ToList();
                foreach (string missingMaterial in missingMaterials) Console.WriteLine($"Note for LOD author: Skipped\t{missingMaterial}");
            }

            // Add lod meshes to static records
            Console.WriteLine("Assigning LOD models...");

            foreach (var staticRecord in state.LoadOrder.PriorityOrder.Static().WinningOverrides())
            {
                // Skip null statics.
                if (staticRecord is null || staticRecord.Model is null || staticRecord.Model.File is null) continue;

                string modelFile = staticRecord.Model.File.ToLower();

                // Split model file name path to see if it is from a dlc.
                string baseFolder = modelFile.Split(Path.DirectorySeparatorChar)[0];

                string possibleLOD4Mesh;
                string possibleLOD8Mesh;
                string possibleLOD16Mesh;
                string possibleLOD32Mesh;
                string possibleLODMesh;
                string[] assignedlodMeshes = { "", "", "", "" };
                bool hasLodMeshes = false;

                string colorRemap = "";
                if (staticRecord.Model.ColorRemappingIndex is not null)
                {
                    colorRemap = $"_{staticRecord.Model.ColorRemappingIndex}";
                    if (Settings.devSettings.verboseConsoleLog) Console.WriteLine($"Note for LOD author: {staticRecord.FormKey} Static has a Color Remapping Index of {staticRecord.Model.ColorRemappingIndex}.");
                }

                // Get file names of possible lod meshes based off the filename (e.g. meshes\somefolder\somemodel.nif would match to meshes\lod\somefolder\somemodel_lod_0.nif).
                switch (baseFolder)
                {
                    case "dlc03":
                        possibleLOD4Mesh = $"{modelFile.Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_0.nif")}";
                        possibleLOD8Mesh = $"{modelFile.Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_1.nif")}";
                        possibleLOD16Mesh = $"{modelFile.Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_2.nif")}";
                        possibleLOD32Mesh = $"{modelFile.Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_3.nif")}";
                        possibleLODMesh = $"{modelFile.Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod.nif")}";
                        break;
                    case "dlc04":
                        possibleLOD4Mesh = $"{modelFile.Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_0.nif")}";
                        possibleLOD8Mesh = $"{modelFile.Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_1.nif")}";
                        possibleLOD16Mesh = $"{modelFile.Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_2.nif")}";
                        possibleLOD32Mesh = $"{modelFile.Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_3.nif")}";
                        possibleLODMesh = $"{modelFile.Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod.nif")}";
                        break;
                    default:
                        possibleLOD4Mesh = $"lod\\{modelFile.Replace(".nif", $"{colorRemap}_lod_0.nif")}";
                        possibleLOD8Mesh = $"lod\\{modelFile.Replace(".nif", $"{colorRemap}_lod_1.nif")}";
                        possibleLOD16Mesh = $"lod\\{modelFile.Replace(".nif", $"{colorRemap}_lod_2.nif")}";
                        possibleLOD32Mesh = $"lod\\{modelFile.Replace(".nif", $"{colorRemap}_lod_3.nif")}";
                        possibleLODMesh = $"lod\\{modelFile.Replace(".nif", $"{colorRemap}_lod.nif")}";
                        break;
                }

                // Check if the possible lod meshes do actually exist. If they do, add them to the list of lod meshes to possibly assign.
                if (lod4Meshes.Contains(possibleLOD4Mesh))
                {
                    hasLodMeshes = true;
                    assignedlodMeshes[0] = possibleLOD4Mesh;
                }
                else if (lodMeshes.Contains(possibleLODMesh))
                {
                    hasLodMeshes = true;
                    assignedlodMeshes[0] = possibleLODMesh;
                }
                if (lod8Meshes.Contains(possibleLOD8Mesh))
                {
                    hasLodMeshes = true;
                    assignedlodMeshes[1] = possibleLOD8Mesh;
                }
                if (lod16Meshes.Contains(possibleLOD16Mesh))
                {
                    hasLodMeshes = true;
                    assignedlodMeshes[2] = possibleLOD16Mesh;
                }
                if (lod32Meshes.Contains(possibleLOD32Mesh))
                {
                    hasLodMeshes = true;
                    assignedlodMeshes[3] = possibleLOD32Mesh;
                }

                string RuleHasDistantLOD = "true";
                List<string> RuleLodMeshes = new();

                bool hasLODRules = false;
                if (LODRules is not null && LODRules.ContainsKey(modelFile))
                {
                    RuleHasDistantLOD = LODRules[modelFile]["hasdistantlod"];
                    RuleLodMeshes.Add(LODRules[modelFile]["level0"]);
                    RuleLodMeshes.Add(LODRules[modelFile]["level1"]);
                    RuleLodMeshes.Add(LODRules[modelFile]["level2"]);
                    RuleLodMeshes.Add(LODRules[modelFile]["level3"]);
                    hasLODRules = true;
                }

                // Skip statics that don't have any lod meshes
                if (!hasLodMeshes && !hasLODRules) continue;

                // Retrieve any DistantLods meshes currently assigned.
                List<string> currentLodMeshes = new();
                foreach (var distantLodList in staticRecord.DistantLods)
                {
                    if (distantLodList.Mesh.Length > 0)
                        currentLodMeshes.Add(distantLodList.Mesh.ToLower());
                }

                while (currentLodMeshes.Count < 4)
                    currentLodMeshes.Add("");

                // Checks to see if DistantLods meshes detected are assigned.
                bool hasDistantLodMeshesChanged = true;
                for (int i = 0; i < 4; i++)
                {
                    if (hasLODRules)
                    {
                        assignedlodMeshes[i] = RuleLodMeshes[i];
                        continue;
                    }

                    // Is there an assigned lod mesh found?
                    bool FoundLodMesh = false;
                    if (assignedlodMeshes[i].Length > 0)
                        FoundLodMesh = true;

                    // Is there an already existing assigned lod mesh?
                    bool ExistingLodMesh = false;
                    if (currentLodMeshes is not null && currentLodMeshes.Count > i)
                        ExistingLodMesh = true;

                    // If there is no found lod mesh, but one is already assigned, use it.
                    if (!FoundLodMesh && ExistingLodMesh && currentLodMeshes is not null)
                        assignedlodMeshes[i] = currentLodMeshes[i];
                }

                if (currentLodMeshes is not null && assignedlodMeshes.SequenceEqual(currentLodMeshes))
                    hasDistantLodMeshesChanged = false;

                bool hasDistantLodFlag = Enums.HasFlag(staticRecord.MajorRecordFlagsRaw, (int)Static.MajorFlag.HasDistantLod);

                // Skip if the static already has the HasDistantLOD flag and its lod meshes hasn't changed.
                if (hasDistantLodFlag && !hasDistantLodMeshesChanged && (!hasLODRules || hasLODRules && RuleHasDistantLOD == "true")) continue;

                if (!hasDistantLodFlag && hasLODRules && RuleHasDistantLOD =="false") continue;

                // Add the static to the patch
                var myFavoriteStatic = state.PatchMod.Statics.GetOrAddAsOverride(staticRecord);

                // Set the HasDistantLOD flag.
                if (RuleHasDistantLOD == "false")
                    myFavoriteStatic.MajorRecordFlagsRaw = Enums.SetFlag(myFavoriteStatic.MajorRecordFlagsRaw, (int)Static.MajorFlag.HasDistantLod, false);
                else
                    myFavoriteStatic.MajorRecordFlagsRaw = Enums.SetFlag(myFavoriteStatic.MajorRecordFlagsRaw, (int)Static.MajorFlag.HasDistantLod, true);
                    
                // Optional readout of static with its lod meshes assigned.
                if (Settings.devSettings.verboseConsoleLog)
                    Console.WriteLine($"{myFavoriteStatic.FormKey}     {assignedlodMeshes[0]}     {assignedlodMeshes[1]}     {assignedlodMeshes[2]}     {assignedlodMeshes[3]}");
                    
                // Clear assigned DistantLods meshes.
                myFavoriteStatic.DistantLods.Clear();

                // Assign DistantLods meshes.
                for (int i = 0; i < 4; i++)
                {
                    if (assignedlodMeshes[i].Length > 0)
                    {
                        var item = new DistantLod()
                        {
                            Mesh = assignedlodMeshes[i],
                            Data = new byte[260 - assignedlodMeshes[i].Length - 1],
                        };
                        myFavoriteStatic.DistantLods.Add(item);
                    }
                }
            }


            //Add lod meshes for moveable statics... this might be hard lol
            IDictionary<Mutagen.Bethesda.Plugins.FormKey, Mutagen.Bethesda.Plugins.FormKey> movableStaticLod = new Dictionary<Mutagen.Bethesda.Plugins.FormKey, Mutagen.Bethesda.Plugins.FormKey>();
            IDictionary<Mutagen.Bethesda.Plugins.FormKey, Mutagen.Bethesda.Plugins.FormKey> movableStaticLodMaterialSwaps = new Dictionary<Mutagen.Bethesda.Plugins.FormKey, Mutagen.Bethesda.Plugins.FormKey>();
            if (Settings.moveableStatics)
            {
                Console.WriteLine("Adding LOD for Moveable Statics...");

                foreach (var moveableStaticRecord in state.LoadOrder.PriorityOrder.MovableStatic().WinningOverrides())
                {
                    // Skip null statics.
                    if (moveableStaticRecord is null || moveableStaticRecord.Model is null || moveableStaticRecord.Model.File is null) continue;

                    // Split model file name path to see if it is from a dlc.
                    string baseFolder = moveableStaticRecord.Model.File.Split(Path.DirectorySeparatorChar)[0].ToLower();

                    string possibleLOD4Mesh;
                    string possibleLOD8Mesh;
                    string possibleLOD16Mesh;
                    string possibleLOD32Mesh;
                    string[] assignedlodMeshes = { "", "", "", "" };
                    bool hasLodMeshes = false;

                    string colorRemap = "";
                    if (moveableStaticRecord.Model.ColorRemappingIndex is not null)
                    {
                        colorRemap = $"_{moveableStaticRecord.Model.ColorRemappingIndex}";
                        if (Settings.devSettings.verboseConsoleLog) Console.WriteLine($"Note for LOD author: {moveableStaticRecord.FormKey} Moveable Static has a Color Remapping Index of {moveableStaticRecord.Model.ColorRemappingIndex}.");
                    }

                    // Get file names of possible lod meshes based off the filename (e.g. meshes\somefolder\somemodel.nif would match to meshes\lod\somefolder\somemodel_lod_0.nif).
                    switch (baseFolder)
                    {
                        case "dlc03":
                            possibleLOD4Mesh = $"{moveableStaticRecord.Model.File.ToLower().Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_0.nif")}";
                            possibleLOD8Mesh = $"{moveableStaticRecord.Model.File.ToLower().Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_1.nif")}";
                            possibleLOD16Mesh = $"{moveableStaticRecord.Model.File.ToLower().Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_2.nif")}";
                            possibleLOD32Mesh = $"{moveableStaticRecord.Model.File.ToLower().Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_3.nif")}";
                            break;
                        case "dlc04":
                            possibleLOD4Mesh = $"{moveableStaticRecord.Model.File.ToLower().Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_0.nif")}";
                            possibleLOD8Mesh = $"{moveableStaticRecord.Model.File.ToLower().Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_1.nif")}";
                            possibleLOD16Mesh = $"{moveableStaticRecord.Model.File.ToLower().Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_2.nif")}";
                            possibleLOD32Mesh = $"{moveableStaticRecord.Model.File.ToLower().Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_3.nif")}";
                            break;
                        default:
                            possibleLOD4Mesh = $"lod\\{moveableStaticRecord.Model.File.ToLower().Replace(".nif", $"{colorRemap}_lod_0.nif")}";
                            possibleLOD8Mesh = $"lod\\{moveableStaticRecord.Model.File.ToLower().Replace(".nif", $"{colorRemap}_lod_1.nif")}";
                            possibleLOD16Mesh = $"lod\\{moveableStaticRecord.Model.File.ToLower().Replace(".nif", $"{colorRemap}_lod_2.nif")}";
                            possibleLOD32Mesh = $"lod\\{moveableStaticRecord.Model.File.ToLower().Replace(".nif", $"{colorRemap}_lod_3.nif")}";
                            break;
                    }

                    // Check if the possible lod meshes do actually exist. If they do, add them to the list of lod meshes to possibly assign.
                    if (lod4Meshes.Contains(possibleLOD4Mesh))
                    {
                        hasLodMeshes = true;
                        assignedlodMeshes[0] = possibleLOD4Mesh;
                    }
                    if (lod8Meshes.Contains(possibleLOD8Mesh))
                    {
                        hasLodMeshes = true;
                        assignedlodMeshes[1] = possibleLOD8Mesh;
                    }
                    if (lod16Meshes.Contains(possibleLOD16Mesh))
                    {
                        hasLodMeshes = true;
                        assignedlodMeshes[2] = possibleLOD16Mesh;
                    }
                    if (lod32Meshes.Contains(possibleLOD32Mesh))
                    {
                        hasLodMeshes = true;
                        assignedlodMeshes[3] = possibleLOD32Mesh;
                    }

                    // Skip moveable statics that don't have any lod meshes
                    if (!hasLodMeshes) continue;

                    // Add a new fake static record for the moveable static
                    var fakeStatic = state.PatchMod.Statics.AddNew("FOLIP_" + moveableStaticRecord.EditorID + "_FakeStatic");
                    fakeStatic.MajorRecordFlagsRaw = (int)Static.MajorFlag.HasDistantLod;
                    fakeStatic.Model = new Model();
                    if (moveableStaticRecord.Model.MaterialSwap is not null)
                        fakeStatic.Model.MaterialSwap.SetTo(moveableStaticRecord.Model.MaterialSwap);
                    if (moveableStaticRecord.Model.ColorRemappingIndex is not null)
                        fakeStatic.Model.ColorRemappingIndex = moveableStaticRecord.Model.ColorRemappingIndex;
                    fakeStatic.ObjectBounds = new ObjectBounds();
                    if (moveableStaticRecord.ObjectBounds is not null)
                    {
                        fakeStatic.ObjectBounds.First = moveableStaticRecord.ObjectBounds.First;
                        fakeStatic.ObjectBounds.Second = moveableStaticRecord.ObjectBounds.Second;
                    }

                    // Add the lods to the fake static
                    for (int i = 0; i < 4; i++)
                    {
                        if (assignedlodMeshes[i].Length > 0)
                        {
                            var item = new DistantLod()
                            {
                                Mesh = assignedlodMeshes[i],
                                Data = new byte[260 - assignedlodMeshes[i].Length - 1],
                            };
                            fakeStatic.DistantLods.Add(item);
                        }
                    }
                    movableStaticLod.Add(moveableStaticRecord.FormKey, fakeStatic.FormKey);
                    if (moveableStaticRecord.Model.MaterialSwap is not null)
                        movableStaticLodMaterialSwaps.Add(moveableStaticRecord.FormKey, moveableStaticRecord.Model.MaterialSwap.FormKey);
                }
            }

            if (Settings.moveableStatics)
            {
                //furniture
                foreach (var furnitureRecord in state.LoadOrder.PriorityOrder.Furniture().WinningOverrides())
                {
                    // Skip null statics.
                    if (furnitureRecord is null || furnitureRecord.Model is null || furnitureRecord.Model.File is null) continue;

                    // Split model file name path to see if it is from a dlc.
                    string baseFolder = furnitureRecord.Model.File.Split(Path.DirectorySeparatorChar)[0].ToLower();

                    string possibleLOD4Mesh;
                    string possibleLOD8Mesh;
                    string possibleLOD16Mesh;
                    string possibleLOD32Mesh;
                    string[] assignedlodMeshes = { "", "", "", "" };
                    bool hasLodMeshes = false;

                    string colorRemap = "";
                    if (furnitureRecord.Model.ColorRemappingIndex is not null)
                    {
                        colorRemap = $"_{furnitureRecord.Model.ColorRemappingIndex}";
                        if (Settings.devSettings.verboseConsoleLog) Console.WriteLine($"Note for LOD author: {furnitureRecord.FormKey} Moveable Static has a Color Remapping Index of {furnitureRecord.Model.ColorRemappingIndex}.");
                    }

                    // Get file names of possible lod meshes based off the filename (e.g. meshes\somefolder\somemodel.nif would match to meshes\lod\somefolder\somemodel_lod_0.nif).
                    switch (baseFolder)
                    {
                        case "dlc03":
                            possibleLOD4Mesh = $"{furnitureRecord.Model.File.ToLower().Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_0.nif")}";
                            possibleLOD8Mesh = $"{furnitureRecord.Model.File.ToLower().Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_1.nif")}";
                            possibleLOD16Mesh = $"{furnitureRecord.Model.File.ToLower().Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_2.nif")}";
                            possibleLOD32Mesh = $"{furnitureRecord.Model.File.ToLower().Replace("dlc03\\", "dlc03\\lod\\").Replace(".nif", $"{colorRemap}_lod_3.nif")}";
                            break;
                        case "dlc04":
                            possibleLOD4Mesh = $"{furnitureRecord.Model.File.ToLower().Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_0.nif")}";
                            possibleLOD8Mesh = $"{furnitureRecord.Model.File.ToLower().Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_1.nif")}";
                            possibleLOD16Mesh = $"{furnitureRecord.Model.File.ToLower().Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_2.nif")}";
                            possibleLOD32Mesh = $"{furnitureRecord.Model.File.ToLower().Replace("dlc04\\", "dlc04\\lod\\").Replace(".nif", $"{colorRemap}_lod_3.nif")}";
                            break;
                        default:
                            possibleLOD4Mesh = $"lod\\{furnitureRecord.Model.File.ToLower().Replace(".nif", $"{colorRemap}_lod_0.nif")}";
                            possibleLOD8Mesh = $"lod\\{furnitureRecord.Model.File.ToLower().Replace(".nif", $"{colorRemap}_lod_1.nif")}";
                            possibleLOD16Mesh = $"lod\\{furnitureRecord.Model.File.ToLower().Replace(".nif", $"{colorRemap}_lod_2.nif")}";
                            possibleLOD32Mesh = $"lod\\{furnitureRecord.Model.File.ToLower().Replace(".nif", $"{colorRemap}_lod_3.nif")}";
                            break;
                    }

                    // Check if the possible lod meshes do actually exist. If they do, add them to the list of lod meshes to possibly assign.
                    if (lod4Meshes.Contains(possibleLOD4Mesh))
                    {
                        hasLodMeshes = true;
                        assignedlodMeshes[0] = possibleLOD4Mesh;
                    }
                    if (lod8Meshes.Contains(possibleLOD8Mesh))
                    {
                        hasLodMeshes = true;
                        assignedlodMeshes[1] = possibleLOD8Mesh;
                    }
                    if (lod16Meshes.Contains(possibleLOD16Mesh))
                    {
                        hasLodMeshes = true;
                        assignedlodMeshes[2] = possibleLOD16Mesh;
                    }
                    if (lod32Meshes.Contains(possibleLOD32Mesh))
                    {
                        hasLodMeshes = true;
                        assignedlodMeshes[3] = possibleLOD32Mesh;
                    }

                    // Skip moveable statics that don't have any lod meshes
                    if (!hasLodMeshes) continue;

                    // Add a new fake static record for the moveable static
                    var fakeStatic = state.PatchMod.Statics.AddNew("FOLIP_" + furnitureRecord.EditorID + "_FakeStatic");
                    fakeStatic.MajorRecordFlagsRaw = (int)Static.MajorFlag.HasDistantLod;
                    fakeStatic.Model = new Model();
                    if (furnitureRecord.Model.MaterialSwap is not null)
                        fakeStatic.Model.MaterialSwap.SetTo(furnitureRecord.Model.MaterialSwap);
                    if (furnitureRecord.Model.ColorRemappingIndex is not null)
                        fakeStatic.Model.ColorRemappingIndex = furnitureRecord.Model.ColorRemappingIndex;
                    fakeStatic.ObjectBounds = new ObjectBounds();
                    if (furnitureRecord.ObjectBounds is not null)
                    {
                        fakeStatic.ObjectBounds.First = furnitureRecord.ObjectBounds.First;
                        fakeStatic.ObjectBounds.Second = furnitureRecord.ObjectBounds.Second;
                    }

                    // Add the lods to the fake static
                    for (int i = 0; i < 4; i++)
                    {
                        if (assignedlodMeshes[i].Length > 0)
                        {
                            var item = new DistantLod()
                            {
                                Mesh = assignedlodMeshes[i],
                                Data = new byte[260 - assignedlodMeshes[i].Length - 1],
                            };
                            fakeStatic.DistantLods.Add(item);
                        }
                    }
                    movableStaticLod.Add(furnitureRecord.FormKey, fakeStatic.FormKey);
                    if (furnitureRecord.Model.MaterialSwap is not null)
                        movableStaticLodMaterialSwaps.Add(furnitureRecord.FormKey, furnitureRecord.Model.MaterialSwap.FormKey);
                }
            }

            if (Settings.moveableStatics)
            {
                //Iterate over placed objects.

                foreach (var placedObjectGetter in state.LoadOrder.PriorityOrder.OnlyEnabled().PlacedObject().WinningContextOverrides(state.LinkCache))
                {
                    if (!movableStaticLod.ContainsKey(placedObjectGetter.Record.Base.FormKey)) continue;
                    if (!placedObjectGetter.TryGetParentContext<IWorldspace, IWorldspaceGetter>(out var worldspaceContext)) continue;
                    //placedObjectGetter.TryGetParentContext<ICell, ICellGetter>(out var cellContext);
                    //if (cellContext is null) continue;
                    //bool isItPrecombined = false;
                    //if (cellContext is not null && cellContext.Record.CombinedMeshReferences is not null && !Enums.HasFlag(placedObjectGetter.Record.MajorRecordFlagsRaw, 256))
                    //{
                    //    foreach (var combinedReference in cellContext.Record.CombinedMeshReferences)
                    //        if (combinedReference.Reference.FormKey == placedObjectGetter.Record.FormKey)
                    //        {
                    //            isItPrecombined = true;
                    //            break;
                    //        }
                    //}
                    //if (!isItPrecombined)
                    //{
                    //    var placedObjectOverride = placedObjectGetter.GetOrAddAsOverride(state.PatchMod);
                    //    placedObjectOverride.MajorRecordFlagsRaw = Enums.SetFlag(placedObjectOverride.MajorRecordFlagsRaw, 256, true);
                    //}
                    //var worldspace = worldspaceContext.Record.FormKey;
                    //var cell = cellContext.Record.FormKey;
                    //var position = placedObjectGetter.Record.Position;
                    //var rotation = placedObjectGetter.Record.Rotation;
                    //var baseObject = movableStaticLod[placedObjectGetter.Record.Base.FormKey];
                    IPlacedObject copiedPlacedObject = placedObjectGetter.DuplicateIntoAsNewRecord(state.PatchMod);
                    copiedPlacedObject.Base.SetTo(movableStaticLod[placedObjectGetter.Record.Base.FormKey]);
                }
            }

            // Fix bugs in mods

            IFallout4ModGetter? AnnexTheCommonwealth = state.LoadOrder.TryGetValue(ModKey.FromFileName("AnnexTheCommonwealth.esm"))?.Mod ?? null;
            if (AnnexTheCommonwealth is not null)
            {
                foreach (var staticRecord in AnnexTheCommonwealth.Statics)
                {
                    if (!Enums.HasFlag(staticRecord.MajorRecordFlagsRaw, (int)Static.MajorFlag.HasDistantLod)) continue;

                    //add it to the patch
                    var myFavoriteStatic = state.PatchMod.Statics.GetOrAddAsOverride(staticRecord);

                    //remove flag
                    myFavoriteStatic.MajorRecordFlagsRaw = Enums.SetFlag(staticRecord.MajorRecordFlagsRaw, (int)Static.MajorFlag.HasDistantLod, false);
                    Console.WriteLine($"Removed HasDistantLOD flag from {staticRecord.FormKey}.");
                }
            }

            //IFallout4ModGetter? modtochecklodmeshes = state.LoadOrder.TryGetValue(ModKey.FromFileName("Optimized Vanilla Tree LODs.esp"))?.Mod ?? null;
            //if (modtochecklodmeshes is not null)
            //{
            //    foreach (var staticRecord in modtochecklodmeshes.Statics)
            //    {
            //        if (!Enums.HasFlag(staticRecord.MajorRecordFlagsRaw, (int)Static.MajorFlag.HasDistantLod)) continue;
            //        if (staticRecord is null || staticRecord.Model is null) continue;
            //        List<string> LODMeshes = new();
            //        foreach (var lodMesh in staticRecord.DistantLods)
            //        {
            //            LODMeshes.Add(lodMesh.Mesh);
            //        }
            //        while (LODMeshes.Count < 4)
            //        {
            //            LODMeshes.Add("");
            //        }

            //        Console.WriteLine("\"" + staticRecord.Model.File + "\": {");
            //        Console.WriteLine("  \"hasdistantlod\": \"true\",");
            //        Console.WriteLine($"  \"level0\": \"{LODMeshes[0]}\",");
            //        Console.WriteLine($"  \"level1\": \"{LODMeshes[1]}\",");
            //        Console.WriteLine($"  \"level2\": \"{LODMeshes[2]}\",");
            //        Console.WriteLine($"  \"level3\": \"{LODMeshes[3]}\"");
            //        Console.WriteLine("},");
            //    }
            //}
        }
    }
}
